主对象：转发服务器
子对象：客户端，主控服务器

收发数据
主对象：不直接收发数据，向子对象交换数据。
子对象：直接向连接对象收发数据。


资源管理：
	需求：
		1、能合理的封装系统资源初始化以及系统资源的获得。
		2、能保证程序结束时自动释放系统资源。
		3、能合理的封装socket的初始化以及连接的创建。
		4、能保证连接断开时，能及时的释放socket连接，避免socket资源的占用。
		5、能将合理的封装数据的发送以及接受，使socket的收发功能更专业化的应用于本项目。
	实现：
		1、采用两层封装的结构，分别封装系统资源以及socket资源。
		2、利用对象的构造，封装资源的申请。
		3、利用对象的析构，保证资源的释放。
		4、socket封装实现socket连接以及数据收发底层的基本管理，第二层封装根据项目的需求，开发特定的功能。
		

socket层析构对象：
	需求：
		1、关闭对象的socket连接
		2、结束关于对象的线程
	实现：
			在socket_connect类中设置一个结束标志位 shared_ptr<bool> d_flag ，当析构对象时设置d_flag为true。由于在子线程保存了d_flag的副本，
		所以当对象被析构时，d_flag指向的内存不会被释放。子线程获取d_flag的中断信号，结束循环，结束线程。至此完成析构。

转发数据：
	需求：
		1、发送方设置发送的目标
		2、接收方获得发送的来源
		3、能根据设置的发送目标转发数据
	实现：
			发送方不必关注发送者是谁，接收方也不必关注接收方是谁。定义了typedef std::pair<int,int> data_head ，data_head在中转服务器中，
		第一个元素标志发送方id，第二个元素标志接收方id，发送时总是发送第一个元素以及数据。所以发送方向缓冲区压入数据时，将目标id压入第一个元素，
		中转服务器将接收的目标id压入第二个元素，把发送方id压入第一个元素。中转服务器向接收方发送数据时，发送一个元素（即发送方id）。
		接收方解析发送方id。至此实现了：发送方指定接收方id，以及接收方获得发送方id。

使用指南：
	添加发送和接受数据的类型：
		1、缓存区分别添加两种类型。
		2、缓存区的用户接口分别添加两种类型。
		3、updatesendbuff、updaterecvbuff函数内分别添加两种类型。
		4、s_send、s_recv分别添加两种数据的收发。
		5、s_senddata添加发送类型的标号。